import java.util.ArrayList;
import java.util.List;

public class Scanner {
	private final String source;
	private final List<Token> tokens = new ArrayList();
	private int start = 0;
	private int current = 0;
	private int line = 1;
	
	public Scanner(String source) {
		this.source = source;
	}
	
	public List<Token> scanTokens() {
		while(!isAtEnd()) {
			start = current;
			scanToken();
		}
		
		tokens.add(new Token(TokenType.EOF, "", null, line));
		return tokens;
	}
	
	private boolean isAtEnd() {
		return current >= source.length();
	}
	
	private void scanToken() {
		char c = advance();
		switch(c) {
		case '(': addToken(TokenType.LEFT_PAREN); break;
		case ')': addToken(TokenType.RIGHT_PAREN); break;
		case '{': addToken(TokenType.LEFT_BRACE); break;
		case '}': addToken(TokenType.RIGHT_BRACE); break;
		case '.': addToken(TokenType.DOT); break;
		case ',': addToken(TokenType.COMMA); break;
		case '+': addToken(TokenType.PLUS); break;
		case '-': addToken(TokenType.MINUS); break;
		case ';': addToken(TokenType.SEMICOLON); break;
		case '*': addToken(TokenType.STAR); break;
		case '!': addToken(match('=') ? TokenType.BANG_EQUAL : TokenType.BANG); break;
		case '=': addToken(match('=') ? TokenType.EQUAL_EQUAL : TokenType.EQUAL); break;
		case '>': addToken(match('=') ? TokenType.GREATER_EQUAL : TokenType.GREATER); break;
		case '<': addToken(match('=') ? TokenType.LESS_EQUAL : TokenType.LESS); break;
		case '/':
			if(match('/')) {
				while(peek() != '\n' && !isAtEnd()) advance();
			} else {
				addToken(TokenType.SLASH);
			}
			break;
		case '"': string(); break;
		default:
			if(isDigit(c)) {
				number();
			} else if (isAlpha(c)) {
				identifier();
			} else {
				Lox.error(line, "Unexpected character: " + c);
			}
		}
	}
	
	private void string() {
		while(peek() != '"' && !isAtEnd()) {
			if(peek() == '\n') line++;
			advance();
		}
		//Unterminated
		if(isAtEnd()) {
			Lox.error(line, "Unterminated string");
			return;
		}
		advance();//closing "
		//We trim the quotes
		String value = source.substring(start + 1, current -1);
		addToken(TokenType.STRING, value);
	}
	
	private void number() {
		while(isDigit(peek())) advance();

		if(peek() == '.' && isDigit(peekNext())) {
			advance();
			while(isDigit(peek())) advance();
		}
		
		addToken(TokenType.NUMBER, Double.parseDouble(source.substring(start, current)));
	}
	
	private void identifier() {
		while(isAlpha(peek()) || isDigit(peek())) advance();
		
		String value = source.substring(start, current);
		
		switch (value) {
		case "var": addToken(TokenType.VAR); break;
		case "and": addToken(TokenType.AND); break;
		case "class": addToken(TokenType.CLASS); break;
		case "else": addToken(TokenType.ELSE); break;
		case "false": addToken(TokenType.FAlSE); break;
		case "for": addToken(TokenType.FOR); break;
		case "fun": addToken(TokenType.FUN); break;
		case "if": addToken(TokenType.IF); break;
		case "nil": addToken(TokenType.NIL); break;
		case "or": addToken(TokenType.OR); break;
		case "print": addToken(TokenType.PRINT); break;
		case "return": addToken(TokenType.RETURN); break;
		case "super": addToken(TokenType.SUPER); break;
		case "this": addToken(TokenType.THIS); break;
		case "true": addToken(TokenType.TRUE); break;
		case "while": addToken(TokenType.WHILE); break;
			default: addToken(TokenType.IDENTIFIER, value); break;
			
		}
	}
	
	private boolean isDigit(char c) {
		return c >= '0' && c <= '9';
	}
	
	private boolean isAlpha(char c) {
		return (c >= 'a' && c  <= 'z')
				||
				(c >= 'A' && c <= 'Z')
				|| 
				c == '_'
				;
	}
	
	private char advance() {
		current++;
		return source.charAt(current - 1);
	}
	
	private void addToken(TokenType type) {
		addToken(type, null);
	}
	
	private void addToken(TokenType type, Object literal) {
		String text = source.substring(start, current);
		tokens.add(new Token(type, text, literal, line));
	}
	private boolean match(char expected) {
		if(isAtEnd()) return false;
		if (source.charAt(current) != expected) return false;
		current++;
		return true;
	}
	
	private char peek() {
		if(isAtEnd()) return '\n';
		return source.charAt(current);
	}

	private char peekNext() {
		if(current + 1 >= source.length()) return '\0';
		return source.charAt(current + 1);
	}
}
